<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="标准C," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="文件是存储在外部介质上数据的集合。操作系统是以文件为单位对数据进行管理的，从操作系统角度看，每一个与主机相联的输入输出设备都看作是一个文件，例如：终端键盘是输入文件，显示屏和打印机是输出文件。在程序运行时，常常需要将一些数据输出到磁盘文件上，而有时却需要将磁盘文件上某些数据输入到内存中参与运算。所以从“内存 → 文件”是输出过程(写)，而从”文件 → 内存”是输入过程(读)，即读是输入，写是输出。">
<meta name="keywords" content="标准C">
<meta property="og:type" content="article">
<meta property="og:title" content="标准C12-标准IO操作">
<meta property="og:url" content="http://yoursite.com/2017/10/08/标准C12-标准IO操作/index.html">
<meta property="og:site_name" content="林夕相心编程者">
<meta property="og:description" content="文件是存储在外部介质上数据的集合。操作系统是以文件为单位对数据进行管理的，从操作系统角度看，每一个与主机相联的输入输出设备都看作是一个文件，例如：终端键盘是输入文件，显示屏和打印机是输出文件。在程序运行时，常常需要将一些数据输出到磁盘文件上，而有时却需要将磁盘文件上某些数据输入到内存中参与运算。所以从“内存 → 文件”是输出过程(写)，而从”文件 → 内存”是输入过程(读)，即读是输入，写是输出。">
<meta property="og:image" content="http://yoursite.com/images/shot/屏幕快照%202017-10-22%20下午4.41.14.png">
<meta property="og:image" content="http://yoursite.com/images/shot/屏幕快照%202017-10-22%20下午4.48.33.png">
<meta property="og:image" content="http://yoursite.com/images/shot/屏幕快照%202017-10-29%20下午3.29.14.png">
<meta property="og:image" content="http://yoursite.com/images/shot/屏幕快照%202017-10-29%20下午3.31.45.png">
<meta property="og:image" content="http://yoursite.com/images/shot/屏幕快照%202017-10-29%20下午3.58.28.png">
<meta property="og:image" content="http://yoursite.com/images/shot/屏幕快照%202017-10-29%20下午3.58.56.png">
<meta property="og:updated_time" content="2017-10-29T09:19:00.744Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="标准C12-标准IO操作">
<meta name="twitter:description" content="文件是存储在外部介质上数据的集合。操作系统是以文件为单位对数据进行管理的，从操作系统角度看，每一个与主机相联的输入输出设备都看作是一个文件，例如：终端键盘是输入文件，显示屏和打印机是输出文件。在程序运行时，常常需要将一些数据输出到磁盘文件上，而有时却需要将磁盘文件上某些数据输入到内存中参与运算。所以从“内存 → 文件”是输出过程(写)，而从”文件 → 内存”是输入过程(读)，即读是输入，写是输出。">
<meta name="twitter:image" content="http://yoursite.com/images/shot/屏幕快照%202017-10-22%20下午4.41.14.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":0,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Cyril'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/08/标准C12-标准IO操作/"/>





  <title>标准C12-标准IO操作 | 林夕相心编程者</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5b14b309dc9d53f5df46697f54cca52b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">林夕相心编程者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">诉说着我的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/标准C12-标准IO操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cyril ouyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林夕相心编程者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">标准C12-标准IO操作</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T16:00:00+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言基础/" itemprop="url" rel="index">
                    <span itemprop="name">C语言基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/10/08/标准C12-标准IO操作/" class="leancloud_visitors" data-flag-title="标准C12-标准IO操作">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"> 阅读统计</i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  11,361
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  47
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>文件是存储在外部介质上数据的集合。操作系统是以文件为单位对数据进行管理的，从操作系统角度看，每一个与主机相联的输入输出设备都看作是一个文件，例如：终端键盘是输入文件，显示屏和打印机是输出文件。在程序运行时，常常需要将一些数据输出到磁盘文件上，而有时却需要将磁盘文件上某些数据输入到内存中参与运算。所以从“内存 → 文件”是输出过程(写)，而从”文件 → 内存”是输入过程(读)，即读是输入，写是输出。</p>
<p>根据数据的组织形式文件分为：ASCII(文本)文件；二进制文件。</p>
<a id="more"></a>
<p>源文件是文本文件，而目标文件、可执行文件和库文件是二进制文件。文本文件是用来保存字符的，文件中的字节都是某种编码(例如ASCII或UTF-8)的字符，用cat命令可以查看其中的字符，用vi可以编辑其中的字符，而二进制文件不是用来保存字符的，文件中的字节表示其它含义，例如可执行文件中有些字节表示指令，有些字节表示各Section和Segment在文件中的位置，有些字节表示各Segment的加载地址。    </p>
<h1 id="C标准库的I-O缓冲区"><a href="#C标准库的I-O缓冲区" class="headerlink" title="C标准库的I/O缓冲区"></a>C标准库的I/O缓冲区</h1><h2 id="缓冲文件系统"><a href="#缓冲文件系统" class="headerlink" title="缓冲文件系统"></a>缓冲文件系统</h2><p>UNIX 下 C 对文件有两种处理办法：缓冲文件系统；非缓冲文件系统。</p>
<ul>
<li>缓冲文件系统：文件系统自动地在内存区为每一个正在使用的文件开辟一块缓冲区。这样从内存向磁盘输出数据必须先送到对应的缓冲区，装满缓冲区后再一起写到磁盘；从磁盘向内存读入数据则一次从磁盘文件将一批数据输入到对应的缓冲区，然后再从缓冲区逐字节的将数据送到内存程序数据区(给程序变量)。缓冲区的大小由各个具体的 C 版本确定，一般为 512 字节。</li>
<li>非缓冲文件系统：文件系统不自动开辟确定大小的缓冲区。<br><img src="/images/shot/屏幕快照 2017-10-22 下午4.41.14.png" alt="屏幕快照 2017-10-22 下午4.41.14"><br>ANSI C 标准实现的是缓冲文件系统，即<strong>C标准库会为每个打开的文件分配一个I/O缓冲区以加速读写操作</strong>。通过文件的FILE结构体指针可以找到该文件的I/O缓冲区。</li>
</ul>
<h2 id="C标准I-O库函数读写文件过程"><a href="#C标准I-O库函数读写文件过程" class="headerlink" title="C标准I/O库函数读写文件过程"></a>C标准I/O库函数读写文件过程</h2><p>用户程序调用C标准I/O库函数读写文件或设备时，这些库函数会通过系统调用把读写请求传给内核，最终由内核来驱动磁盘或设备完成I/O操作。但这些库函数大多数时候都在I/O缓冲区中读写，只有少数时候需要把读写请求传给内核。</p>
<p>以fgetc/fputc为例，描述C标准I/O库函数读写文件的具体过程：<br><strong>读过程</strong>：当用户程序第一次调用fgetc读一个字节时，fgetc函数可能通过系统调用进入内核读1K字节到I/O缓冲区中，然后返回I/O缓冲区中的第一个字节给用户，把读写位置指向I/O缓冲区中的第二个字节，以后用户再调fgetc，就直接从I/O缓冲区中读取，而不需要进内核了。当用户把这1K字节都读完之后，再次调用fgetc时，fgetc函数会再次进入内核读1K字节到I/O缓冲区中。<br><strong>写过程</strong>：当用户程序调用fputc写一个字节时，通常只是写到I/O缓冲区中，这样fputc函数可以很快地返回，如果I/O缓冲区写满了，fputc就会通过系统调用把I/O缓冲区中的数据传给内核，最终由内核把数据写回磁盘。有时候用户程序希望把I/O缓冲区中的数据立刻传给内核，让内核写回设备，这称为Flush操作，对应的C标准库函数是fflush，注意fclose函数在关闭文件之前也会自动做Flush操作。</p>
<p>在这个场景中用户程序、C标准库和内核之间的关系就像CPU、Cache和内存之间的关系一样，C标准库之所以会从内核预读一些数据放在I/O缓冲区中，是希望用户程序随后要用到这些数据，C标准库的I/O缓冲区也在用户空间，直接从用户空间读取数据要比进内核读数据快得多。</p>
<p>下图以fgets/fputs示意了I/O缓冲区的作用，注意区分用户程序的缓冲区和C标准库的I/O缓冲区。<br><img src="/images/shot/屏幕快照 2017-10-22 下午4.48.33.png" alt="屏幕快照 2017-10-22 下午4.48.33"></p>
<h2 id="C标准库的I-O缓冲区类型"><a href="#C标准库的I-O缓冲区类型" class="headerlink" title="C标准库的I/O缓冲区类型"></a>C标准库的I/O缓冲区类型</h2><p>C标准库的I/O缓冲区有三种类型：全缓冲、行缓冲和无缓冲。当用户程序调用库函数做写操作时，不同类型的缓冲区具有不同的特性。</p>
<ul>
<li>全缓冲：如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。</li>
<li>行缓冲：如果用户程序写的数据中有换行符就把这一行写回内核，或者如果缓冲区写满了就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。</li>
<li>无缓冲：用户程序每次调标准库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。</li>
</ul>
<p>下面通过一个简单的例子证明标准输出对应终端设备时是行缓冲的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main() </div><div class="line">&#123;</div><div class="line">	printf(&quot;hello world&quot;);</div><div class="line">	while(1);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gcc下运行这个程序，会发现hello world并没有打印到屏幕上。因为标准输出是行缓冲的，printf(“hello world”);打印的字符串中没有换行符，所以只会把字符串写到标准输出的I/O缓冲区中而不会写回内核(写到终端设备)。用Ctrl-C终止它，把打印语句改成printf(“hello world\n”);有了换行符，再试一次就会立刻写到终端设备：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./a.out </div><div class="line">hello world$</div></pre></td></tr></table></figure></p>
<p>hello world被打印到屏幕上，后面直接跟Shell提示符，中间没有换行。</p>
<h2 id="Flush操作"><a href="#Flush操作" class="headerlink" title="Flush操作"></a>Flush操作</h2><p>Flush操作：把I/O缓冲区中的数据立刻传给内核，让内核写回设备，这称为Flush操作。</p>
<p>自动flush时机：</p>
<ul>
<li>main函数return时，会自动调用exit，而exit函数会自动关闭所有尚未关闭的文件，而每个文件关闭之前会自动做Flush操作</li>
<li>缓冲区被写满时，会自动做Flush操作</li>
<li>向无缓冲文件写数据时，每次写操作都会自动做Flush操作</li>
<li>向行缓冲文件写入换行符时，会自动做Flush操作</li>
<li>从行缓冲的文件中读取数据时，会自动Flush所有行缓冲</li>
</ul>
<p>强制Flush：调用fflush函数，可以确保数据写回内核，以免进程异常终止时丢失数据。调用fflush(NULL)可以对所有打开文件的I/O缓冲区做Flush操作。</p>
<p>我们知道main函数被启动代码这样调用：exit(main(argc, argv));。main函数return时启动代码会调用exit，exit函数首先会关闭所有尚未关闭的文件(文件关闭之前要做Flush操作)，然后通过_exit系统调用进入内核退出当前进程。在上一个例子中，如果敲Ctrl-C，进程是异常终止的，并没有调用exit，也就没有机会Flush I/O缓冲区，因此字符串最终不会打印到屏幕上。如果把while(1); 去掉就可以写到终端设备，因为程序退出时会调用exit从而Flush所有I/O缓冲区。<br>如果在程序中直接调用_exit退出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int main() </div><div class="line">&#123;</div><div class="line">	printf(&quot;hello world&quot;);</div><div class="line">	_exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果不会把字符串打印到屏幕上，把_exit调用改成exit就可以打印到屏幕上了。</p>
<p>继续做一个修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int main() </div><div class="line">&#123;</div><div class="line">	char buf[20];</div><div class="line">	printf(&quot;Please input a line: &quot;); </div><div class="line">	fgets(buf, 20, stdin);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然调用printf并不会把字符串写到设备，但紧接着调用fgets读一个行缓冲的文件(标准输入)，在读取之前会自动Flush所有行缓冲包括标准输出，所以会在屏幕上打印出字符串。</p>
<p>如果用户程序不想完全依赖于自动的Flush操作，可以调fflush函数手动做Flush操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int fflush(FILE *stream); </div><div class="line">返回值: 成功返回0, 出错返回EOF并设置errno</div></pre></td></tr></table></figure></p>
<p>对前面的例子再稍加改动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main() </div><div class="line">&#123;</div><div class="line">	printf(&quot;hello world&quot;);</div><div class="line">	fflush(stdout);</div><div class="line">	while(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然字符串中没有换行，但用户程序调用fflush强制写回内核，因此会在屏幕上打印出字符串。</p>
<h1 id="流和文件指针"><a href="#流和文件指针" class="headerlink" title="流和文件指针"></a>流和文件指针</h1><p>流：程序和数据源之间的一个通道，数据源可以是文件、内存或是网络连接。</p>
<p>文件指针：表示一个打开的文件，包含了管理文件流的信息。</p>
<p>缓冲文件系统中，关键的概念是“文件指针”。每个被使用的文件都在内存中开辟一个区，用来存放文件的有关信息(如文件的名字，文件状态及当前读写位置等)，这些信息是保存在一个结构体变量中的，该结构体类型是在C标准库中定义的，取名为FILE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	short         level;   /* 缓冲区“满”或“空”的程度 */</div><div class="line">	unsigned      flags;   /* 文件状态标志 */</div><div class="line">	char          fd;      /* 文件描述符 */</div><div class="line">	unsigned char hold;    /* 如无缓冲区不读取字符 */</div><div class="line">	short         bsize;   /* 缓冲区的大小 */</div><div class="line">	unsigned char * buffer;/* 数据缓冲区的位置 */</div><div class="line">	unsigned ar   * curp;  /* 当前的指向 */</div><div class="line">	unsigned      istemp;  /* 临时文件，指示器 */</div><div class="line">	short         token;   /* 用于有效性检查 */</div><div class="line">&#125;FILE;</div></pre></td></tr></table></figure></p>
<p>通过文件指针变量能够找到与它相关的文件，可以实现对该文件的访问。</p>
<h1 id="标准I-O库函数"><a href="#标准I-O库函数" class="headerlink" title="标准I/O库函数"></a>标准I/O库函数</h1><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>在操作文件之前要用fopen打开文件，操作完毕要用fclose关闭文件。打开文件就是在操作系统中分配一些资源用于保存该文件的状态信息，并得到该文件的标识，以后用户程序就可以用这个标识对文件做各种操作，关闭文件则释放文件在操作系统中占用的资源，使文件的标识失效，用户程序就无法再操作这个文件了。标准C中如果打开文件成功，就返回一个FILE <em>文件指针来标识这个文件，以后调用其它函数对文件做读写操作都要提供这个指针，以指明对哪个文件进行操作。FILE是C标准库中定义的结构体类型，其中包含该文件在内核中的标识(文件描述符)、I/O缓冲区和当前读写位置等信息，但调用者不必知道FILE结构体都有哪些成员，我们很快就会看到，调用者只是把文件指针在库函数接口之间传来传去，而文件指针所指的FILE结构体的成员在库函数内部维护，调用者不应该直接访问这些成员，这种编程思想在面向对象方法论中称为封装。像FILE </em>这样的指针称为不透明指针或者叫句柄，FILE *指针就像一个把手，抓住这个把手就可以打开门或抽屉，但用户只能抓这个把手，而不能直接抓门或抽屉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	FILE *fopen(const char *path, const char *mode);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	打开文件</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功将创建一个流并返回指向该流的文件指针，出错返回NULL并设置errno</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	path: 文件的路径名(相对路径或绝对路径)</div><div class="line">	mode: 打开模式</div></pre></td></tr></table></figure></p>
<p>mode参数是一个字符串，由rwatb+六个字符组合而成，r表示读，w表示写，a表示追加，在文件末尾追加数据使文件的尺寸增大。t表示文本文件，b表示二进制文件，t也可以省略不写。如果省略t和b，rwa+四个字符有以下6种合法的组合：</p>
<table>
<thead>
<tr>
<th>文件打开模式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“r”      （只读）</td>
<td>只读，文件必须已存在</td>
</tr>
<tr>
<td>“w”     （只写）</td>
<td>只写，如果文件不存在则创建，如果文件已存在则把文件长度截断（Truncate）为0字节</td>
</tr>
<tr>
<td>“a”      （追加）</td>
<td>只能在文件末尾追加数据，如果文件不存在则创建</td>
</tr>
<tr>
<td>“r+”    （读写）</td>
<td>读写，文件必须已存在</td>
</tr>
<tr>
<td>“w+”   （读写）</td>
<td>读写，如果文件不存在则创建，如果文件已存在则把文件长度截断（Truncate）为0字节</td>
</tr>
<tr>
<td>“a+”    （读写）</td>
<td>读，追加数据，如果文件不存在则创建</td>
</tr>
</tbody>
</table>
<p>以上6个组合都是打开文本文件的方式，可以分别加上b表示打开二进制文件。</p>
<table>
<thead>
<tr>
<th>文件打开模式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“rb”      （只读）</td>
<td>只读，文件必须已存在</td>
</tr>
<tr>
<td>“wb”     （只写）</td>
<td>只写，如果文件不存在则创建，如果文件已存在则把文件长度截断（Truncate）为0字节</td>
</tr>
<tr>
<td>“ab”      （追加）</td>
<td>只能在文件末尾追加数据，如果文件不存在则创建</td>
</tr>
<tr>
<td>“rb+”    （读写）</td>
<td>读写，文件必须已存在</td>
</tr>
<tr>
<td>“wb+”   （读写）</td>
<td>读写，如果文件不存在则创建，如果文件已存在则把文件长度截断（Truncate）为0字节</td>
</tr>
<tr>
<td>“ab+”    （读写）</td>
<td>读，追加数据，如果文件不存在则创建</td>
</tr>
</tbody>
</table>
<p>在程序开始运行时，系统自动打开 3 个标准文件：标准输入，标准输出，标准错误输出。通常这 3 个文件都与终端相联系，因此以前我们所用到的从终端输入或输出都不需要打开终端文件，系统自动定义了 3 个文件指针：stdin 指向终端输入，stdout 指向终端输出，stderr 指向标准错误输出(也是向终端输出的)，如果程序中指定要从 stdin 所指的文件输入数据，就是指从终端键盘输入数据。</p>
<h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h2><p>fclose 函数关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才释放文件指针变量，可以防止在向文件写数据时因缓冲区未满而程序结束造成数据丢失。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	int fclose(FILE *fp);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	关闭文件</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回0, 出错返回EOF并设置errno</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	fp: 文件指针</div></pre></td></tr></table></figure></p>
<p>EOF在stdio.h中定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* End of file character.</div><div class="line">Some things throughout the library rely on this being -1. */</div><div class="line">#ifndef EOF</div><div class="line"># define EOF (-1) </div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>fopen调用应该和fclose调用配对，打开文件操作完之后一定要记得关闭。如果不调用fclose，在进程退出时系统会自动关闭文件，但是不能因此就忽略fclose调用，如果写一个长年累月运行的程序(比如网络服务器程序)，打开的文件都不关闭，堆积得越来越多，就会占用越来越多的系统资源。</p>
<h2 id="操作读写位置的函数"><a href="#操作读写位置的函数" class="headerlink" title="操作读写位置的函数"></a>操作读写位置的函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	int fseek(FILE *stream, long offset, int whence);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	设置文件的当前读写位置</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回0, 出错返回-1并设置errno</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	stream: 文件指针</div><div class="line">	offset: 偏移量</div><div class="line">		offset可正可负，负值表示向前(文件开头的方向)移动, 正值表示向后(文件末尾的方向)移动, 如果向前移动</div><div class="line">		的字节数超过了文件开头则出错返回, 如果向后移动的字节数超过了文件末尾, 再次写入时将增大文件尺寸从原</div><div class="line">		来的文件末尾到fseek移动之后的读写位置之间的字节都是0。</div><div class="line">	whence: 偏移参考位置</div><div class="line">		SEEK_SET: 从文件开头移动offset个字节</div><div class="line">		SEEK_CUR: 从当前位置移动offset个字节</div><div class="line">		SEEK_END: 从文件末尾移动offset个字节</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	long ftell(FILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	获取文件的当前读写位置</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回当前读写位置, 出错返回-1并设置errno</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	void rewind(FILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	把文件的当前读写位置重置到文件开头</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	无</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<h2 id="以字节为单位的I-O函数"><a href="#以字节为单位的I-O函数" class="headerlink" title="以字节为单位的I/O函数"></a>以字节为单位的I/O函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	int fgetc(FILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	从stream所指文件中读取一个字节，每调用一次fgetc读写位置向后移动一个字节</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功将读取的一个字节内容转化成int型返回, 出错或读到文件末尾返回EOF</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int getchar(void);      /* 相当于fgetc(stdin); */</div><div class="line">int getc(FILE *stream); /* getc的功能与fgetc相同，但为了提高效率，它一般被实现为宏。*/</div></pre></td></tr></table></figure>
<p>fgetc成功时返回读到的一个字节，本来应该是unsigned char型的，但由于函数原型中返回值是int型，所以这个字节要转换成int型再返回，那为什么要规定返回值是int型呢？是因为出错或读到文件末尾时fgetc将返回EOF，即-1，保存在int型的返回值中是0xffffffff，如果读到字节0xff，由unsigned char型转换为int型是0x000000ff，只有规定返回值是int型才能把这两种情况区分开，如果规定返回值是unsigned char型，那么当返回值是0xff时无法区分到底是EOF还是字节0xff。注意fgetc读到文件末尾时返回EOF，只是用这个返回值表示已读到文件末尾，并不是说每个文件末尾都有一个字节是EOF(根据上面的分析EOF并不是一个字节)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	int fputc(int c, FILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	向stream所指文件写入一个字节, 每调用一次fputc读写位置向后移动一个字节</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回写入的字节, 出错返回EOF</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	c: 待写入的字节, 写入前会自动先将其转化为unsigned char类型 </div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int putchar(int c);           /* 相当于fputc(c, stdout); */</div><div class="line">int putc(int c, FILE *stream);/* putc的功能与fputc相同，但为了提高效率，它一般被实现为宏。*/</div></pre></td></tr></table></figure>
<h2 id="以字符串为单位的I-O函数"><a href="#以字符串为单位的I-O函数" class="headerlink" title="以字符串为单位的I/O函数"></a>以字符串为单位的I/O函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	char *fgets(char *s, int size, FILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	从stream所指文件中读取以&apos;\n&apos;结尾的一行字符(包括&apos;\n&apos;在内)然后加上&apos;\0&apos;存入缓冲区s中</div><div class="line">	</div><div class="line">	如果从文件中读了size-1个字符还没读到&apos;\n&apos;, 就把已读到的size-1个字符加上&apos;\0&apos;存入缓冲区;</div><div class="line">	如果读入若干字符后到达文件末尾, 则将已读到的字符加上&apos;\0&apos;存入缓冲区;(再次调用fgets将返回NULL)</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回s指针, 出错或者读到文件末尾返回NULL</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	s: 缓冲区的首地址</div><div class="line">	size: 缓冲区的长度</div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char *gets(char *s); /* 从标准输入读一行字符到调用者提供的缓冲区中, 可能导致缓冲区溢出, Never Use */</div></pre></td></tr></table></figure>
<p>注意，对于fgets来说，’\n’是一个特别的字符，而’\0’并无任何特别之处，如果读到’\0’就当作普通字符读入。如果文件中存在’\0’字符(或者说0x00字节)，调用fgets之后就无法判断缓冲区中的’\0’究竟是从文件读上来的字符还是由fgets自动添加的结束符，所以<strong>fgets只适合读文本文件而不适合读二进制文件</strong>，并且文本文件中的所有字符都应该是可见字符，不能有’\0’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	int fputs(const char *s, FILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	向stream所指文件写入一个字符串, 不包括结尾的&apos;\0&apos;。</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回输出的字符个数, 失败返回EOF</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	s: 缓冲区的首地址, 用来保存要输出的字符串</div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int puts(const char *s);/* 向标准输出写入一个字符串不包括结尾&apos;\0&apos;,然后自动写一个&apos;\n&apos;到标准输出 */</div></pre></td></tr></table></figure>
<p>与fgets不同的是，fputs并不关心的字符串中的’\n’字符，字符串中可以有’\n’也可以没有’\n’。<strong>注意puts会在最后自动写一个’\n’而fputs不会。</strong></p>
<h2 id="以记录为单位的I-O函数"><a href="#以记录为单位的I-O函数" class="headerlink" title="以记录为单位的I/O函数"></a>以记录为单位的I/O函数</h2><p>fread和fwrite用于读写记录，这里的记录是指一串固定长度的字节，比如一个int、一个结构体或一个定长数组。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	从stream所指文件中读取size * nmemb个字节保存到ptr中</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回读取到的记录数(块数), 出错或读到文件末尾返回0</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	ptr: 存储读取出来的数据 </div><div class="line">	size: 一条记录的长度(一块数据的大小) </div><div class="line">	nmemb: 要读取的记录数(数据块数)</div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">函数原型：</div><div class="line">	size_t fwrite(const void *ptr, size_t size, size_t nmemb, ßFILE *stream);</div><div class="line">	</div><div class="line">函数功能：</div><div class="line">	向stream所指文件写入size * nmemb个字节</div><div class="line">	</div><div class="line">所属头文件</div><div class="line">	#include &lt;stdio.h&gt;</div><div class="line">	</div><div class="line">返回值</div><div class="line">	成功返回写入的记录数(块数), 出错返回0</div><div class="line">	</div><div class="line">参数说明</div><div class="line">	ptr: 存储要写入文件的数据</div><div class="line">	size: 一条记录的长度(一块数据的大小)</div><div class="line">	nmemb: 要写入的记录数(数据块数)</div><div class="line">	stream: 文件指针</div></pre></td></tr></table></figure>
<p>nmemb是请求读或写的记录数，fread和fwrite返回的记录数有可能小于nmemb指定的记录数。例如当前读写位置距文件末尾只有一条记录的长度，调用fread时指定nmemb为2，则返回值为1。</p>
<h2 id="格式化I-O函数"><a href="#格式化I-O函数" class="headerlink" title="格式化I/O函数"></a>格式化I/O函数</h2><p>现在该正式讲一下printf和scanf函数了，这两个函数都有很多种形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int printf(const char *format, ...);</div><div class="line">int fprintf(FILE *stream, const char *format, ...);</div><div class="line">int sprintf(char *str, const char *format, ...);</div><div class="line">int snprintf(char *str, size_t size, const char *format, ...);</div><div class="line"></div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line">int vprintf(const char *format, va_list ap);</div><div class="line">int vfprintf(FILE *stream, const char *format, va_list ap);</div><div class="line">int vsprintf(char *str, const char *format, va_list ap);</div><div class="line">int vsnprintf(char *str, size_t size, const char *format, va_list ap);</div><div class="line"></div><div class="line">返回值: 成功返回格式化输出的字节数(不包括字符串的结尾&apos;\0&apos;), 出错返回一个负值</div></pre></td></tr></table></figure></p>
<p>printf格式化打印到标准输出，而fprintf打印到指定的文件stream中。sprintf并不打印到文件，而是打印到用户提供的缓冲区str中并在末尾加’\0’，由于格式化后的字符串长度很难预计，所以很可能造成缓冲区溢出，用snprintf更好一些，参数size指定了缓冲区长度，如果格式化后的字符串长度超过缓冲区长度，snprintf就把字符串截断到size-1字节，再加上一个’\0’写入缓冲区，也就是说snprintf保证字符串以’\0’结尾。snprintf的返回值是格式化后的字符串长度(不包括结尾的’\0’)，如果字符串被截断，返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比较就可以知道是否发生了截断。</p>
<p>上面列出的后四个函数在前四个函数名的前面多了个v，表示可变参数不是以…的形式传进来，而是以va_list类型传进来。下面我们用vsnprintf包装出一个类似printf的带格式化字符串和可变参数的函数。</p>
<p>示例：实现格式化打印错误的err_sys函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">#define MAXLINE 80</div><div class="line"></div><div class="line">void err_sys(const char *fmt, ...) </div><div class="line">&#123;</div><div class="line">	int err = errno; </div><div class="line">	char buf[MAXLINE+1]; </div><div class="line">	va_list ap;</div><div class="line">	</div><div class="line">    va_start(ap, fmt);</div><div class="line">    </div><div class="line">    vsnprintf(buf, MAXLINE, fmt, ap);</div><div class="line">	snprintf(buf+strlen(buf), MAXLINE-strlen(buf), &quot;: %s&quot;, strerror(err));</div><div class="line">	strcat(buf, &quot;\n&quot;); </div><div class="line">	fputs(buf, stderr);</div><div class="line">	</div><div class="line">	va_end(ap);</div><div class="line">	exit(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">	FILE *fp;</div><div class="line">    if (argc != 2) &#123;</div><div class="line">		fputs(&quot;Usage: ./a.out pathname\n&quot;, stderr);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line">	fp = fopen(argv[1], &quot;r&quot;);</div><div class="line">	if (fp == NULL) </div><div class="line">        err_sys(&quot;Line %d - Open file %s&quot;, __LINE__, argv[1]);</div><div class="line">    printf(&quot;Open %s OK\n&quot;, argv[1]);</div><div class="line">	fclose(fp);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了err_sys函数，不仅简化了main函数的代码，而且可以把fopen的错误提示打印得非常清楚，有源代码行号，有打开文件的路径名，一看就知道哪里出错了。        </p>
<p>现在总结一下printf格式化字符串中和转换说明有哪些写法。在这里只列举几种常用的格式，其它格式请参考Man Page。每个转换说明以%号开头，以转换字符结尾，我们以前用过的转换说明仅包含%号和转换字符，例如%d、%s，其实在这两个字符中间还可以插入一些可选项。</p>
<p>常用的printf转换说明可选项：<br><img src="/images/shot/屏幕快照 2017-10-29 下午3.29.14.png" alt="屏幕快照 2017-10-29 下午3.29.14"></p>
<p>常用的printf转换字符：<br><img src="/images/shot/屏幕快照 2017-10-29 下午3.31.45.png" alt="屏幕快照 2017-10-29 下午3.31.45"></p>
<p>我们讲过可变参数的原理，printf并不知道实际参数的类型，只能按转换说明指出的参数类型从栈帧上取参数，所以如果实际参数和转换说明的类型不符，结果可能会有些意外，上面也举过几个这样的例子。另外如果s指向一个字符串，用printf(s)打印这个字符串可能得到错误的结果，因为字符串中可能包含%号而被printf当成转换说明，printf并不知道后面没有传其它参数，照样会从栈帧上取参数。所以比较保险的办法是printf(“%s”, s)。</p>
<p>下面看scanf函数的各种形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int scanf(const char *format, ...);</div><div class="line">int fscanf(FILE *stream, const char *format, ...);</div><div class="line">int sscanf(const char *str, const char *format, ...);</div><div class="line"></div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line">int vscanf(const char *format, va_list ap);</div><div class="line">int vsscanf(const char *str, const char *format, va_list ap);</div><div class="line">int vfscanf(FILE *stream, const char *format, va_list ap); </div><div class="line"></div><div class="line">返回值: 返回成功匹配和赋值的参数个数, 成功匹配的参数可能少于所提供的赋值参数, 返回0表示一个都不匹配, 出错或者读到文件或字符串末尾时返回EOF并设置errno</div></pre></td></tr></table></figure></p>
<p>scanf从标准输入读字符，按格式化字符串format中的转换说明解释这些字符，转换后赋给后面的参数，后面的参数都是传出参数，因此必须传地址而不能传值。fscanf从指定的文件stream中读字符，而sscanf从指定的字符串str中读字符。后面三个以v开头的函数的可变参数不是以…的形式传进来，而是以va_list类型传进来。</p>
<p>现在总结一下scanf的格式化字符串和转换说明，这里也只列举几种常用的格式，其它格式请参考Man Page。scanf用输入的字符去匹配格式化字符串中的字符和转换说明，如果成功匹配一个转换说明，就给一个参数赋值，如果读到文件或字符串末尾就停止，或者如果遇到和格式化字符串不匹配的地方(比如转换说明是%d却读到字符A)就停止。如果遇到不匹配的地方而停止，scanf的返回值可能小于赋值参数的个数，文件的读写位置指向输入中不匹配的地方，下次调用库函数读文件时可以从这个位置继续。<br>​<br>格式化字符串中包括：</p>
<ul>
<li>空格或Tab，在处理过程中被忽略。</li>
<li>普通字符(不包括%)，和输入字符中的非空白字符相匹配。输入字符中的空白字符是指空格、Tab、\r、\n、\v、\f。</li>
<li>转换说明，以%开头，以转换字符结尾，中间也有若干个可选项。</li>
</ul>
<p>转换说明中的可选项有：</p>
<ul>
<li>*号，表示这个转换说明只是用来匹配一段输入字符，但匹配结果并不赋给后面的参数。</li>
<li>用一个整数指定的宽度N。表示这个转换说明最多匹配N个输入字符，或者匹配到输入字符中的下一个空白字符结束。</li>
<li>对于整型参数可以指定字长，有hh、h、l、ll(也可以写成一个L)，含义和printf相同。但l和L还有一层含义，当转换字符是e、f、g时，表示赋值参数的类型是float <em>而非double </em>，这一点跟printf不同，这时前面加上l或L分别表示double <em>或long double </em>型。</li>
</ul>
<p>常用的scanf转换字符有：<br><img src="/images/shot/屏幕快照 2017-10-29 下午3.58.28.png" alt="屏幕快照 2017-10-29 下午3.58.28"><br><img src="/images/shot/屏幕快照 2017-10-29 下午3.58.56.png" alt="屏幕快照 2017-10-29 下午3.58.56"></p>
<p>示例：用scanf实现简单的计算器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main(void) /* rudimentary calculator */ </div><div class="line">&#123;</div><div class="line">	double sum, v;</div><div class="line">	</div><div class="line">	sum = 0;</div><div class="line">	while (scanf(&quot;%lf&quot;, &amp;v) == 1)</div><div class="line">		printf(&quot;\t%.2f\n&quot;, sum += v); </div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们要读取25 Dec 1988这样的日期格式，可以这样写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">char *str = &quot;25 Dec 1988&quot;; </div><div class="line">int day, year;</div><div class="line">char monthname[20];</div><div class="line">sscanf(str, &quot;%d %s %d&quot;, &amp;day, monthname, &amp;year);</div></pre></td></tr></table></figure></p>
<p>如果str中的空白字符再多一些，比如” 25 Dec 1998”，仍然可以正确读取。如果格式化字符串中的空格和Tab再多一些，比如”%d %s %d “，也可以正确读取。scanf函数是很强大的，但是要用对了不容易，需要多练习，通过练习体会空白字符的作用。</p>
<p>如果要读取12/25/1998这样的日期格式，就需要在格式化字符串中用/匹配输入字符中的/：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int day, month, year;</div><div class="line">scanf(&quot;%d/%d/%d&quot;, &amp;month, &amp;day, &amp;year);</div></pre></td></tr></table></figure></p>
<p>scanf把换行符也看作空白字符，仅仅当作字段之间的分隔符，如果输入中的字段个数不确定，最好是先用fgets按行读取，然后再交给sscanf处理。如果我们的程序需要同时识别以上两种日期格式，可以这样写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while (fgets(line, sizeof(line), stdin) &gt; 0) &#123;</div><div class="line">	if (sscanf(line, &quot;%d %s %d&quot;, &amp;day, monthname, &amp;year) == 3)</div><div class="line">		printf(&quot;valid: %s\n&quot;, line); /* 25 Dec 1988 form */ </div><div class="line">	else if (sscanf(line, &quot;%d/%d/%d&quot;, &amp;month, &amp;day, &amp;year) == 3)</div><div class="line">		printf(&quot;valid: %s\n&quot;, line); /* mm/dd/yy form */</div><div class="line">	else</div><div class="line"> 		printf(&quot;invalid: %s\n&quot;, line); /* invalid form */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="综合实例－实现文件拷贝"><a href="#综合实例－实现文件拷贝" class="headerlink" title="综合实例－实现文件拷贝"></a>综合实例－实现文件拷贝</h2><p>&lt;方法1:fgetc/fputc 实现&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">	int c;</div><div class="line">    FILE *in, *out;</div><div class="line">    if(argc != 3)&#123;</div><div class="line">    	printf(&quot;usage: copy file1 file2\n&quot;);</div><div class="line">		return 1; </div><div class="line">	&#125;</div><div class="line">    if((in = fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</div><div class="line">       printf(&quot;file1 open failed!\n&quot;);</div><div class="line">       return 2;</div><div class="line">    &#125;</div><div class="line">    if((out = fopen(argv[2], &quot;w&quot;)) == NULL)&#123;</div><div class="line">       	printf(&quot;file2 open failed!\n&quot;);</div><div class="line">		return 3; </div><div class="line">	&#125;</div><div class="line">    while((c = fgetc(in)) != EOF)&#123;</div><div class="line">       fputc(c, out);</div><div class="line">    &#125;</div><div class="line">    fclose(in);</div><div class="line">    fclose(out);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>​<br>&lt;方法2:fgets/fputs 实现 &gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    char s[1024];</div><div class="line">    FILE *in, *out;</div><div class="line">    if(argc != 3)&#123;</div><div class="line">        printf(&quot;usage: copy file1 file2\n&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    if((in = fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</div><div class="line">       printf(&quot;file1 open failed!\n&quot;);</div><div class="line">       return 2;</div><div class="line">    &#125;</div><div class="line">    if((out = fopen(argv[2], &quot;w&quot;)) == NULL)&#123;</div><div class="line">        printf(&quot;file2 open failed!\n&quot;);</div><div class="line">        return 3;</div><div class="line">    &#125;</div><div class="line">    while(fgets(s, 1024, in) != NULL)&#123;</div><div class="line">       fputs(s, out);</div><div class="line">    &#125;</div><div class="line">    fclose(in);</div><div class="line">    fclose(out);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&lt;方法3:fread/fwrite 实现 &gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main(int argc,char *argv[])</div><div class="line">&#123;</div><div class="line">    FILE *in,*out;</div><div class="line">    char ch;</div><div class="line">    if(argc != 3)&#123;</div><div class="line">       	printf(&quot;usage:copy file1 file2\n&quot;);</div><div class="line">		return 1; </div><div class="line">	&#125;</div><div class="line">    if((in = fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</div><div class="line">       printf(&quot;file1 open failed!\n&quot;);</div><div class="line">       return 2;</div><div class="line">    &#125;</div><div class="line">    if((out = fopen(argv[2],&quot;w&quot;)) == NULL)&#123;</div><div class="line">       	printf(&quot;file2 open failed!\n&quot;);</div><div class="line">		return 3; </div><div class="line">	&#125;</div><div class="line">    while(fread(&amp;ch, sizeof(char), 1, in) &gt; 0)</div><div class="line">       	fwrite(&amp;ch, sizeof(char), 1, out);</div><div class="line">	return 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&lt;方法4:fscanf/fprintf 实现 &gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(int argc,char *argv[])</div><div class="line">&#123;</div><div class="line">    char ch;</div><div class="line">    FILE *in, *out;</div><div class="line">    if(argc != 3)&#123;</div><div class="line">       printf(&quot;usage:copy file1 file2\n&quot;);</div><div class="line">       return 1;</div><div class="line">    &#125;</div><div class="line">    if((in=fopen(argv[1], &quot;r&quot;)) == NULL)&#123;</div><div class="line">       	printf(&quot;file1 open failed!\n&quot;);</div><div class="line">		return 2; </div><div class="line">	&#125;</div><div class="line">    if((out = fopen(argv[2], &quot;w&quot;)) == NULL)&#123;</div><div class="line">       printf(&quot;file2 open failed!\n&quot;);</div><div class="line">       return 3;</div><div class="line">    &#125;</div><div class="line">    while(fscanf(in, &quot;%c&quot;, &amp;ch) != EOF)</div><div class="line">       fprintf(out, &quot;%c&quot;, ch);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="stdin-stdout-stderr"><a href="#stdin-stdout-stderr" class="headerlink" title="stdin/stdout/stderr"></a>stdin/stdout/stderr</h1><p>我们经常用printf打印到屏幕，也用过scanf读键盘输入，这些也属于I/O操作，但不是对文件做I/O操作而是对终端设备做I/O操作。所谓终端是指人机交互的设备，也就是可以接受用户输入并输出信息给用户的设备。在计算机刚诞生的年代，终端是电传打字机和打印机，现在的终端通常是键盘和显示器。终端设备和文件一样也需要先打开后操作，终端设备也有对应的路径名，/dev/tty就表示和当前进程相关联的终端设备(进程的控制终端)。也就是说/dev/tty不是一个普通的文件，它不表示磁盘上的一组数据，而是表示一个设备。用ls命令查看这个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls -l /dev/tty</div><div class="line">crw-rw-rw- 1 root dialout 5, 0 2009-03-20 19:31 /dev/tty</div></pre></td></tr></table></figure></p>
<p>开头的c表示文件类型是字符设备。中间的5，0是它的设备号，主设备号5，次设备号0，主设备号标识内核中的一个设备驱动程序，次设备号标识该设备驱动程序管理的一个设备。内核通过设备号找到相应的驱动程序，完成对该设备的操作。我们知道常规文件的这一列应该显示文件尺寸，而设备文件的这一列显示设备号，这表明设备文件是没有文件尺寸这个属性的，因为设备文件在磁盘上不保存数据，对设备文件做读写操作并不是读写磁盘上的数据，而是在读写设备。UNIX 的传统是Everything is a file，键盘、显示器、串口、磁盘等设备在/dev目录下都有一个特殊的设备文件与之对应，这些设备文件也可以像普通文件一样打开、读、写和关闭，使用的函数接口是相同的。我们平时不严格区分“文件”和“设备”这两个概念，遇到“文件”这个词时，可以根据上下文理解它是指普通文件还是设备文件，如果需要强调是保存在磁盘上的普通文件，会用“常规文件”这个词。</p>
<p>那为什么printf和scanf不用打开就能对终端设备进行操作呢？因为在程序启动时（在main函数还没开始执行之前）会自动把终端设备打开三次，分别赋给三个FILE *指针stdin、stdout和stderr，这三个文件指针是libc中定义的全局变量，在stdio.h中声明，printf向stdout写，而scanf从stdin读，后面我们会看到，用户程序也可以直接使用这三个文件指针。这三个文件指针的打开方式都是可读可写的，但通常stdin只用于读操作称为标准输入(Standard Input)，stdout只用于写操作称为标准输出(Standard Output)，stderr也只用于写操作称为标准错误输出(Standard Error)，通常程序的运行结果打印到标准输出，而错误提示(例如gcc报的警告和错误)打印到标准错误输出，所以fopen的错误处理写成这样更符合惯例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ( (fp = fopen(&quot;/tmp/file1&quot;, &quot;r&quot;)) == NULL) &#123; </div><div class="line">	fputs(&quot;Error open file /tmp/file1\n&quot;, stderr); </div><div class="line">	exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不管是打印到标准输出还是打印到标准错误输出效果是一样的，都是打印到终端设备(也就是屏幕)了，那为什么还要分成标准输出和标准错误输出呢？以后我们会讲到重定向操作，可以把标准输出重定向到一个常规文件，而标准错误输出仍然对应终端设备，这样就可以把正常的运行结果和错误提示分开，而不是混在一起打印到屏幕了。    </p>
<h1 id="errno与perror函数"><a href="#errno与perror函数" class="headerlink" title="errno与perror函数"></a>errno与perror函数</h1><p>很多系统函数在错误返回时将错误原因记录在libc定义的全局变量errno中，每种错误原因对应一个错误码，请查阅errno(3)的Man Page了解各种错误码，errno在头文件errno.h中声明是个整型变量，所有错误码都是正整数。<br>如果在程序中打印错误信息时直接打印errno变量，打印出来的只是一个整数值，仍然看不出是什么错误。比较好的办法是用perror或strerror函数将errno解释成字符串再打印。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">void perror(const char *s);</div></pre></td></tr></table></figure>
<p>perror函数将错误信息打印到标准错误输出，首先打印参数s所指的字符串，然后打印:号，然后根据当前errno的值打印错误原因。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	FILE *fp = fopen(&quot;abcde&quot;, &quot;r&quot;); </div><div class="line">	if (NULL ＝＝ fp) &#123;</div><div class="line">        perror(&quot;Open file abcde&quot;);</div><div class="line">        exit(1);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果文件abcde不存在，fopen返回-1并设置errno为ENOENT，紧接着perror函数读取errno的值，将ENOENT解释成字符串No such file or directory并打印，最后打印的结果是Open file abcde:No such file or directory。虽然perror可以打印出错误原因，传给perror的字符串参数仍然应该提供一些额外的信息，以便在看到错误信息时能够很快定位是程序中哪里出了错，如果在程序中有很多个fopen调用，每个fopen打开不同的文件，那么在每个fopen的错误处理中打印文件名就很有帮助。如果把上面的程序改成这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	FILE *fp = fopen(&quot;abcde&quot;, &quot;r&quot;); </div><div class="line">	if (NULL ＝＝ fp) &#123;</div><div class="line">        perror(&quot;Open file abcde&quot;);</div><div class="line">        printf(&quot;errno: %d\n&quot;, errno);</div><div class="line">        exit(1);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则printf打印的错误号并不是fopen产生的错误号，而是perror产生的错误号。errno是一个全局变量，很多系统函数都会改变它，fopen函数Man Page中的ERRORS部分描述了它可能产生的错误码，perror函数的Man Page中没有ERRORS部分，说明它本身不产生错误码，但它调用的其它函数也有可能改变errno变量。大多数系统函数都有一个Side Effect，就是有可能改变errno变量(当然也有少数例外，比如strcpy)，所以一个系统函数错误返回后应该马上检查errno，在检查errno之前不能再调用其它系统函数。</p>
<p>strerror函数可以根据错误号返回错误原因字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">char *strerror(int errnum);</div><div class="line">返回值: 错误码errnum所对应的字符串</div></pre></td></tr></table></figure></p>
<p>这个函数返回指向静态内存的指针。以后学线程库时我们会看到，有些函数的错误码并不保存在errno中，而是通过返回值返回，就不能调用perror打印错误原因了，这时strerror就派上了用场：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fputs(strerror(n), stderr);</div></pre></td></tr></table></figure></p>
<h1 id="跨平台文件操作"><a href="#跨平台文件操作" class="headerlink" title="跨平台文件操作"></a>跨平台文件操作</h1><p>下面是我在实际工作中写的，总结了几乎所有的文件操作在file.h中可以看到接口，最重要的是已经实现了跨平台支持(windows, linux, MacOS, Android, iOS)，或许能给读者一些帮助呢！我还总结了很多跨平台的东西，比如延时函数，时间转换函数，线程池什么的都会在日后的文章中慢慢贴出来，希望能帮到你哦！</p>
<p>/<em> config.h </em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#ifndef __CONFIG_H__</div><div class="line">#define __CONFIG_H__</div><div class="line"></div><div class="line">#include &lt;stdint.h&gt;</div><div class="line"></div><div class="line">#define true  1</div><div class="line">#define false 0</div><div class="line">#define STATIC  static</div><div class="line">#define INLINE  inline</div><div class="line"></div><div class="line">#ifdef _MSC_BUILD</div><div class="line">#define fseeko64	_fseeki64</div><div class="line">#define ftello64	_ftelli64</div><div class="line">typedef __int64     off64_t;</div><div class="line">typedef unsigned char                   uint8_t;</div><div class="line">typedef unsigned short int              uint16_t;</div><div class="line">typedef unsigned int                    uint32_t;</div><div class="line">typedef unsigned long long              uint64_t;</div><div class="line">typedef float                           float32;</div><div class="line">typedef double                          float64;</div><div class="line">typedef char                            bool_t;</div><div class="line">#endif</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>/<em> file.h </em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#ifndef __FILE_H__</div><div class="line">#define __FILE_H__</div><div class="line"></div><div class="line">#include &lt;stdint.h&gt;</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot;</div><div class="line">&#123;</div><div class="line">#endif</div><div class="line">    </div><div class="line">int path_format(const char *src, char *dest_buf, int size);//replace all &quot;\\&quot; with &quot;/&quot;</div><div class="line">int path_addPrefix(const char *src, char *dest_buf, int size);//add &quot;/&quot; at the first of path</div><div class="line">int path_addSuffix(const char *src, char *dest_buf, int size);//add &quot;/&quot; at the end of path</div><div class="line">int path_removePrefix(const char *src, char *dest_buf, int size);//remove &quot;/&quot; at the first of path</div><div class="line">int path_removeSuffix(const char *src, char *dest_buf, int size);//remove &quot;/&quot; at the end of path</div><div class="line"></div><div class="line">int isdir(const char *name);//1(yes), 0(no)</div><div class="line"></div><div class="line">int forder_access(const char *name);</div><div class="line">int forder_touch(const char *name, int mode);</div><div class="line"></div><div class="line">int file_rename(const char *oldname, const char *newname);</div><div class="line">int file_remove(const char *name);</div><div class="line">FILE * file_open(const char *name, const char *mode);</div><div class="line">int file_access(const char *name);</div><div class="line">int file_touch(const char *name, int mode);</div><div class="line">int file_mode(const char *name, int *mode);</div><div class="line">int file_size(const char *name, int64_t *fileSize);</div><div class="line">int file_md5(const char *name, char *md5_buf, int size);</div><div class="line">int file_sha1(const char *name, char *sha1_buf, int size);</div><div class="line">int file_lasttime_write(const char *name, time_t *lasttime);</div><div class="line">int file_path(const char *name, char *path_buf, int size);</div><div class="line">int file_name(const char *name, char *name_buf, int size);</div><div class="line">int file_uniqueName(const char *name, char *uniqueName_buf, int size);</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>/<em> file.c </em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#ifdef WIN32</div><div class="line">#include &lt;windows.h&gt;</div><div class="line">#include &lt;io.h&gt;</div><div class="line">#include &lt;direct.h&gt;</div><div class="line">#else</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#define _FILE_OFFSET_BITS (64)</div><div class="line">#endif</div><div class="line">#include &quot;config.h&quot;</div><div class="line">#include &quot;file.h&quot;</div><div class="line">#include &quot;openssl/md5.h&quot;</div><div class="line">#include &quot;openssl/sha.h&quot;</div><div class="line">#include &quot;openssl/crypto.h&quot;</div><div class="line"></div><div class="line">#define PATH_BUF_LEN    (256)</div><div class="line">#define MODE_BUF_LEN	(16)</div><div class="line"></div><div class="line">#ifdef WIN32</div><div class="line">int UTF8ToUnicode(const char* str_utf8, wchar_t* str_unicode)</div><div class="line">&#123;</div><div class="line">	DWORD len_unicode = MultiByteToWideChar(CP_UTF8, 0, str_utf8, -1, NULL, 0);</div><div class="line">	TCHAR *pwText = malloc(sizeof(TCHAR)* len_unicode);</div><div class="line">	if (NULL == pwText)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	MultiByteToWideChar(CP_UTF8, 0, str_utf8, -1, pwText, len_unicode);</div><div class="line">	wcscpy(str_unicode, pwText);</div><div class="line">	free(pwText);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">int path_format(const char *src, char *dest_buf, int size)</div><div class="line">&#123;</div><div class="line">	memset(dest_buf, 0, size);</div><div class="line">	strncpy(dest_buf, src, size);</div><div class="line">	dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	if (dest_buf[strlen(dest_buf) - 1] == &apos;/&apos;)</div><div class="line">	&#123;</div><div class="line">		dest_buf[strlen(dest_buf) - 1] = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	char *str = dest_buf;</div><div class="line">	char *out = strstr(str, &quot;\\&quot;);</div><div class="line">	while (out != NULL)</div><div class="line">	&#123;</div><div class="line">		*out = &apos;/&apos;;</div><div class="line">		++out;</div><div class="line">		str = out;</div><div class="line">		out = strstr(str, &quot;\\&quot;);</div><div class="line">	&#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int path_addPrefix(const char *src, char *dest_buf, int size)</div><div class="line">&#123;</div><div class="line">	memset(dest_buf, 0, size);</div><div class="line">	strncpy(dest_buf, src, size);</div><div class="line">	dest_buf[size-1] = &apos;\0&apos;;</div><div class="line">	if (strcmp(dest_buf, &quot;&quot;) == 0)</div><div class="line">	&#123;</div><div class="line">		dest_buf[0] = &apos;/&apos;;</div><div class="line">		dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	if (dest_buf[0] != &apos;/&apos;)</div><div class="line">	&#123;</div><div class="line">		memmove(dest_buf + 1, dest_buf, strlen(dest_buf));</div><div class="line">		dest_buf[0] = &apos;/&apos;;</div><div class="line">		dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int path_addSuffix(const char *src, char *dest_buf, int size)</div><div class="line">&#123;</div><div class="line">	memset(dest_buf, 0, size);</div><div class="line">	strncpy(dest_buf, src, size);</div><div class="line">	dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	if (strcmp(dest_buf, &quot;&quot;) == 0)</div><div class="line">	&#123;</div><div class="line">		dest_buf[0] = &apos;/&apos;;</div><div class="line">		dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	if (dest_buf[strlen(dest_buf)-1] != &apos;/&apos;)</div><div class="line">	&#123;</div><div class="line">		dest_buf[strlen(dest_buf)] = &apos;/&apos;;</div><div class="line">		dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int path_removePrefix(const char *src, char *dest_buf, int size)</div><div class="line">&#123;</div><div class="line">	memset(dest_buf, 0, size);</div><div class="line">	strncpy(dest_buf, src, size);</div><div class="line">	dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	if (strlen(dest_buf) &gt; 0 &amp;&amp; dest_buf[0] == &apos;/&apos;)</div><div class="line">	&#123;</div><div class="line">		memmove(dest_buf, dest_buf + 1, strlen(dest_buf));</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int path_removeSuffix(const char *src, char *dest_buf, int size)</div><div class="line">&#123;</div><div class="line">	memset(dest_buf, 0, size);</div><div class="line">	strncpy(dest_buf, src, size);</div><div class="line">	dest_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	if (strlen(dest_buf) &gt; 0 &amp;&amp; dest_buf[strlen(dest_buf) - 1] == &apos;/&apos;)</div><div class="line">	&#123;</div><div class="line">		dest_buf[strlen(dest_buf) - 1] = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int isdir(const char *name)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	wchar_t wname[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">	if (UTF8ToUnicode(name, wname) == -1)</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	DWORD attr = GetFileAttributesW(wname);</div><div class="line">	if (attr != INVALID_FILE_ATTRIBUTES &amp;&amp; attr &amp; FILE_ATTRIBUTE_DIRECTORY)</div><div class="line">	&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	#else</div><div class="line">	struct stat buf;</div><div class="line">	if (stat(name, &amp;buf) == 0 &amp;&amp; buf.st_mode &amp; S_IFDIR)</div><div class="line">	&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	#endif</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int forder_access(const char *name)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	/* move last &apos;/&apos; to &apos;\0&apos; */</div><div class="line">	char dest_buf[PATH_BUF_LEN];</div><div class="line">	memset(dest_buf, 0, sizeof(dest_buf));</div><div class="line">	strncpy(dest_buf, name, sizeof(dest_buf));</div><div class="line">	dest_buf[sizeof(dest_buf)-1] = &apos;\0&apos;;</div><div class="line">	if (dest_buf[strlen(dest_buf) - 1] == &apos;/&apos;)</div><div class="line">	&#123;</div><div class="line">		dest_buf[strlen(dest_buf) - 1] = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	wchar_t wname[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">	if (UTF8ToUnicode(dest_buf, wname) == -1)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	return _waccess(wname, 0);</div><div class="line">	#else</div><div class="line">	return access(name, F_OK);</div><div class="line">	#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">int forder_touch(const char *name, int mode)</div><div class="line">&#123;</div><div class="line">	/* add &apos;/&apos; to last */</div><div class="line">	char dest_buf[PATH_BUF_LEN];</div><div class="line">	memset(dest_buf, &apos;\0&apos;, sizeof(dest_buf));</div><div class="line">	path_addSuffix(name, dest_buf, sizeof(dest_buf));</div><div class="line"></div><div class="line">	char onepath[PATH_BUF_LEN];</div><div class="line">	memset(onepath, &apos;\0&apos;, sizeof(onepath));</div><div class="line"></div><div class="line">	char *ptr;</div><div class="line">	char *save = dest_buf;</div><div class="line">	</div><div class="line">	while ((ptr = strstr(save, &quot;/&quot;)) != NULL)</div><div class="line">	&#123;</div><div class="line">		strncat(onepath, save, strlen(save) - strlen(ptr + 1));</div><div class="line">		onepath[sizeof(onepath) - 1] = &apos;\0&apos;;</div><div class="line"></div><div class="line">		if (forder_access(onepath) == -1)//not exist</div><div class="line">		&#123;</div><div class="line">			#ifdef WIN32</div><div class="line">			wchar_t wonepath[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">			if (UTF8ToUnicode(onepath, wonepath) == -1)</div><div class="line">			&#123;</div><div class="line">				return -1;</div><div class="line">			&#125;</div><div class="line">			if (_wmkdir(wonepath) == -1)</div><div class="line">			&#123;</div><div class="line">				return -1;</div><div class="line">			&#125;</div><div class="line">			#else</div><div class="line">			if (mkdir(onepath, mode) == -1)</div><div class="line">			&#123;</div><div class="line">				return -1;</div><div class="line">			&#125;</div><div class="line">			#endif</div><div class="line">		&#125;</div><div class="line">		save = ptr + 1;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_rename(const char *oldname, const char *newname)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	wchar_t woldname[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">	wchar_t wnewname[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">	if (UTF8ToUnicode(oldname, woldname) == -1)</div><div class="line">	&#123;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	if (UTF8ToUnicode(newname, wnewname) == -1)</div><div class="line">	&#123;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	return _wrename(woldname, wnewname);</div><div class="line">	#else</div><div class="line">	return rename(oldname, newname);</div><div class="line">	#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_remove(const char *name)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	wchar_t wname[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">	if (UTF8ToUnicode(name, wname) == -1)</div><div class="line">	&#123;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	return _wremove(wname);</div><div class="line">	#else</div><div class="line">	return remove(name);</div><div class="line">	#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">FILE * file_open(const char *name, const char *mode)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	wchar_t wmode[sizeof(wchar_t)* MODE_BUF_LEN];</div><div class="line">	wchar_t wname[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">	if (UTF8ToUnicode(mode, wmode) == -1)</div><div class="line">	&#123;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	if (UTF8ToUnicode(name, wname) == -1)</div><div class="line">	&#123;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	return _wfopen(wname, wmode);</div><div class="line">	#else</div><div class="line">	return fopen(name, mode);</div><div class="line">	#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_access(const char *name)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	wchar_t wname[sizeof(wchar_t)* PATH_BUF_LEN];</div><div class="line">	if (UTF8ToUnicode(name, wname) == -1)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	return _waccess(wname, 0);</div><div class="line">	#else</div><div class="line">	return access(name, F_OK);</div><div class="line">	#endif</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_touch(const char *name, int mode)</div><div class="line">&#123;</div><div class="line">	if (file_access(name) == -1)</div><div class="line">	&#123;</div><div class="line">		#ifdef WIN32</div><div class="line">		FILE *fp = file_open(name, &quot;w+&quot;);</div><div class="line">		if (NULL == fp)</div><div class="line">		&#123;</div><div class="line">			return -1;</div><div class="line">		&#125;</div><div class="line">		fclose(fp);</div><div class="line">		#else</div><div class="line">		int fd = creat(name, mode);</div><div class="line">		if (fd == -1)</div><div class="line">		&#123;</div><div class="line">			return -1;</div><div class="line">		&#125;</div><div class="line">		close(fd);</div><div class="line">		#endif</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_mode(const char *name, int *mode)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	*mode = (00400 | 00200 | 00100 | 00040 | 00004); //0744</div><div class="line">	#else</div><div class="line">	struct stat buf;</div><div class="line">	if (stat(name, &amp;buf) == 0)</div><div class="line">	&#123;</div><div class="line">		*mode = buf.st_mode;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	#endif</div><div class="line">	return -1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_size(const char *name, int64_t *fileSize)</div><div class="line">&#123;</div><div class="line">	*fileSize = 0;</div><div class="line">	#ifdef WIN32</div><div class="line">	FILE *fp = file_open(name, &quot;r&quot;);</div><div class="line">	if (NULL == fp)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	if (fseeko64(fp, (off64_t)0, SEEK_END) == -1)</div><div class="line">	&#123;</div><div class="line">		fclose(fp);</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	*fileSize = ftello64(fp);</div><div class="line">	fclose(fp);</div><div class="line">	#else</div><div class="line">	struct stat buf;</div><div class="line">	if (stat(name, &amp;buf) == -1)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	*fileSize = buf.st_size;</div><div class="line">	#endif</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_md5(const char *name, char *md5_buf, int size)</div><div class="line">&#123;</div><div class="line">	MD5_CTX ctx;</div><div class="line">	int len = 0;</div><div class="line">	unsigned char buffer[1024] = &#123; 0 &#125;;</div><div class="line">	unsigned char digest[MD5_DIGEST_LENGTH] = &#123; 0 &#125;;</div><div class="line">	FILE *fp = file_open(name, &quot;rb&quot;);</div><div class="line">	if (NULL == fp)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	MD5_Init(&amp;ctx);</div><div class="line">	while ((len = fread(buffer, 1, 1024, fp)) &gt; 0)</div><div class="line">	&#123;</div><div class="line">		MD5_Update(&amp;ctx, buffer, len);</div><div class="line">	&#125;</div><div class="line">	MD5_Final(digest, &amp;ctx);</div><div class="line">	OPENSSL_cleanse(&amp;ctx, sizeof(ctx));</div><div class="line">	fclose(fp);</div><div class="line">	int i = 0;</div><div class="line">	char buf[128] = &#123; 0 &#125;;</div><div class="line">	char tmp[3] = &#123; 0 &#125;;</div><div class="line">	for (i = 0; i &lt; MD5_DIGEST_LENGTH; i++)</div><div class="line">	&#123;</div><div class="line">		sprintf(tmp, &quot;%02X&quot;, digest[i]);</div><div class="line">		strcat(buf, tmp);</div><div class="line">	&#125;</div><div class="line">	memset(md5_buf, 0, size);</div><div class="line">	strncpy(md5_buf, buf, size);</div><div class="line">	md5_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_sha1(const char *name, char *sha1_buf, int size)</div><div class="line">&#123;</div><div class="line">	SHA_CTX ctx;</div><div class="line">	int len = 0;</div><div class="line">	unsigned char buffer[1024] = &#123; 0 &#125;;</div><div class="line">	unsigned char digest[SHA_DIGEST_LENGTH] = &#123; 0 &#125;;</div><div class="line">	FILE *fp = file_open(name, &quot;rb&quot;);</div><div class="line">	if (NULL == fp)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	SHA1_Init(&amp;ctx);</div><div class="line">	while ((len = fread(buffer, 1, 1024, fp)) &gt; 0)</div><div class="line">	&#123;</div><div class="line">		SHA1_Update(&amp;ctx, buffer, len);</div><div class="line">	&#125;</div><div class="line">	SHA1_Final(digest, &amp;ctx);</div><div class="line">	OPENSSL_cleanse(&amp;ctx, sizeof(ctx));</div><div class="line">	fclose(fp);</div><div class="line">	int i = 0;</div><div class="line">	char buf[160] = &#123; 0 &#125;;</div><div class="line">	char tmp[3] = &#123; 0 &#125;;</div><div class="line">	for (i = 0; i &lt; SHA_DIGEST_LENGTH; i++)</div><div class="line">	&#123;</div><div class="line">		sprintf(tmp, &quot;%02X&quot;, digest[i]);</div><div class="line">		strcat(buf, tmp);</div><div class="line">	&#125;</div><div class="line">	memset(sha1_buf, 0, size);</div><div class="line">	strncpy(sha1_buf, buf, size);</div><div class="line">	sha1_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_lasttime_write(const char *name, time_t *lasttime)</div><div class="line">&#123;</div><div class="line">	#ifdef WIN32</div><div class="line">	WIN32_FIND_DATA ffd;</div><div class="line">	HANDLE hFind = FindFirstFile(name, &amp;ffd);</div><div class="line">	if (NULL == hFind)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	FindClose(hFind);</div><div class="line">	FILETIME ft = ffd.ftLastWriteTime;</div><div class="line">	LONGLONG ll;</div><div class="line">	ULARGE_INTEGER ui;</div><div class="line">	ui.LowPart = ft.dwLowDateTime;</div><div class="line">	ui.HighPart = ft.dwHighDateTime;</div><div class="line">	ll = ft.dwHighDateTime &lt;&lt; 32 + ft.dwLowDateTime;</div><div class="line">	*lasttime = ((LONGLONG)(ui.QuadPart - 116444736000000000) / 10000000);</div><div class="line">	#else</div><div class="line">	struct stat buf;</div><div class="line">	if (stat(name, &amp;buf) == -1)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	*lasttime = buf.st_mtime;</div><div class="line">	#endif</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_path(const char *name, char *path_buf, int size)</div><div class="line">&#123;</div><div class="line">	char dest_buf[PATH_BUF_LEN];</div><div class="line">	memset(dest_buf, 0, sizeof(dest_buf));</div><div class="line">	if (path_format(name, dest_buf, sizeof(dest_buf)) == -1)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	memset(path_buf, 0, size);</div><div class="line">	strncpy(path_buf, dest_buf, size);</div><div class="line">	path_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	char *out = strrchr(path_buf, &apos;/&apos;);</div><div class="line">	if (out != NULL)</div><div class="line">	&#123;</div><div class="line">		*(out+1) = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_name(const char *name, char *name_buf, int size)</div><div class="line">&#123;</div><div class="line">    char dest_buf[PATH_BUF_LEN];</div><div class="line">    memset(dest_buf, 0, sizeof(dest_buf));</div><div class="line">    if (path_format(name, dest_buf, sizeof(dest_buf)) == -1)</div><div class="line">    &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    memset(name_buf, 0, size);</div><div class="line">    strncpy(name_buf, dest_buf, size);</div><div class="line">    name_buf[size - 1] = &apos;\0&apos;;</div><div class="line">    char *out = strrchr(name_buf, &apos;/&apos;);</div><div class="line">    if (out != NULL)</div><div class="line">    &#123;</div><div class="line">        memmove(name_buf, out+1, strlen(out));</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int file_uniqueName(const char *name, char *uniqueName_buf, int size)</div><div class="line">&#123;</div><div class="line">	memset(uniqueName_buf, 0, size);</div><div class="line">	strncpy(uniqueName_buf, name, size);</div><div class="line">	uniqueName_buf[size - 1] = &apos;\0&apos;;</div><div class="line">	if (file_access(uniqueName_buf) == -1)//not exist</div><div class="line">	&#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	char suffix[PATH_BUF_LEN];//eg: .txt  .jpg</div><div class="line">	char body[PATH_BUF_LEN];</div><div class="line">	memset(suffix, 0, sizeof(suffix));</div><div class="line">	memset(body, 0, sizeof(body));</div><div class="line">	char *pSpliter = (char *)strrchr(name, &apos;.&apos;);</div><div class="line">	if (pSpliter != NULL)</div><div class="line">	&#123;</div><div class="line">		strncpy(suffix, pSpliter, strlen(pSpliter));</div><div class="line">		suffix[sizeof(suffix) - 1] = &apos;\0&apos;;</div><div class="line">		strncpy(body, name, strlen(name) - strlen(pSpliter));</div><div class="line">		body[sizeof(body)-1] = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		strncpy(body, name, strlen(name));</div><div class="line">		body[sizeof(body) - 1] = &apos;\0&apos;;</div><div class="line">	&#125;</div><div class="line">	int tryNum = 0;</div><div class="line">	while (1)</div><div class="line">	&#123;</div><div class="line">		tryNum++;</div><div class="line">		memset(uniqueName_buf, 0, size);</div><div class="line">		char addstr[PATH_BUF_LEN];</div><div class="line">		memset(addstr, 0, sizeof(addstr));</div><div class="line">		sprintf(addstr, &quot;(%d)&quot;, tryNum);</div><div class="line">		strcat(uniqueName_buf, body);</div><div class="line">		strcat(uniqueName_buf, addstr);</div><div class="line">		strcat(uniqueName_buf, suffix);</div><div class="line">		uniqueName_buf[size-1] = &apos;\0&apos;;</div><div class="line">		if (file_access(uniqueName_buf) == -1)//not exist</div><div class="line">		&#123;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/wechat.png" alt="Cyril ouyang WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/标准C/" rel="tag"># 标准C</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/01/标准C11-字符串操作/" rel="next" title="标准C11-字符串操作">
                <i class="fa fa-chevron-left"></i> 标准C11-字符串操作
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/15/标准C13-变量的存储布局/" rel="prev" title="标准C13-变量的存储布局">
                标准C13-变量的存储布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDU5Mi83MTQ3"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Cyril ouyang" />
          <p class="site-author-name" itemprop="name">Cyril ouyang</p>
           
              <p class="site-description motion-element" itemprop="description">一笔一划练神韵, 一撇一捺树人生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">70</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ouyangxx" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/cyril-90-56/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/Cyril_ouyang" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C标准库的I-O缓冲区"><span class="nav-number">1.</span> <span class="nav-text">C标准库的I/O缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲文件系统"><span class="nav-number">1.1.</span> <span class="nav-text">缓冲文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C标准I-O库函数读写文件过程"><span class="nav-number">1.2.</span> <span class="nav-text">C标准I/O库函数读写文件过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C标准库的I-O缓冲区类型"><span class="nav-number">1.3.</span> <span class="nav-text">C标准库的I/O缓冲区类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flush操作"><span class="nav-number">1.4.</span> <span class="nav-text">Flush操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流和文件指针"><span class="nav-number">2.</span> <span class="nav-text">流和文件指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准I-O库函数"><span class="nav-number">3.</span> <span class="nav-text">标准I/O库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fopen"><span class="nav-number">3.1.</span> <span class="nav-text">fopen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fclose"><span class="nav-number">3.2.</span> <span class="nav-text">fclose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作读写位置的函数"><span class="nav-number">3.3.</span> <span class="nav-text">操作读写位置的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以字节为单位的I-O函数"><span class="nav-number">3.4.</span> <span class="nav-text">以字节为单位的I/O函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以字符串为单位的I-O函数"><span class="nav-number">3.5.</span> <span class="nav-text">以字符串为单位的I/O函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以记录为单位的I-O函数"><span class="nav-number">3.6.</span> <span class="nav-text">以记录为单位的I/O函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化I-O函数"><span class="nav-number">3.7.</span> <span class="nav-text">格式化I/O函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综合实例－实现文件拷贝"><span class="nav-number">3.8.</span> <span class="nav-text">综合实例－实现文件拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stdin-stdout-stderr"><span class="nav-number">4.</span> <span class="nav-text">stdin/stdout/stderr</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#errno与perror函数"><span class="nav-number">5.</span> <span class="nav-text">errno与perror函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#跨平台文件操作"><span class="nav-number">6.</span> <span class="nav-text">跨平台文件操作</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cyril ouyang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("1Mf3MxAb0bt4oJRovBza6TMj-gzGzoHsz", "7eGUphmMMDHDfpj24UEiMviU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>